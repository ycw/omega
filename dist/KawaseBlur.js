import{WebGLRenderTarget as e,Vector2 as t,UniformsUtils as r,ShaderMaterial as s}from"three";import{Pass as n,FullScreenQuad as i}from"three/examples/jsm/postprocessing/Pass.js";import{EffectComposer as o}from"three/examples/jsm/postprocessing/EffectComposer.js";function f(e,t,r,s){if("a"===r&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===r?s:"a"===r?s.call(e):s?s.value:t.get(e)}function a(e,t,r,s,n){if("m"===s)throw new TypeError("Private method is not writable");if("a"===s&&!n)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!n:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===s?n.call(e,r):n?n.value=r:t.set(e,r),r}const u={uniforms:{tDiffuse:{value:null},uOffset:{value:null}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 uOffset;\n    varying vec2 vUv;\n    void main() {\n      gl_FragColor = .25 * (\n        texture2D( tDiffuse, vUv + uOffset )\n        + texture2D( tDiffuse, vUv - uOffset )\n        + texture2D( tDiffuse, vUv + uOffset * vec2( 1., -1. ) )\n        + texture2D( tDiffuse, vUv + uOffset * vec2( -1., 1. ) )\n      );\n    }\n  "};var h,d,l;class c extends n{constructor(e){super();const t=r.clone(u.uniforms);t.uOffset.value=e;const n=new s({uniforms:t,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader});this.fsQuad=new i(n),this.uniforms=n.uniforms,this.shouldRenderToScreen=!1}render(e,t,r){this.uniforms.tDiffuse.value=r.texture,this.shouldRenderToScreen?e.setRenderTarget(null):(e.setRenderTarget(t),this.clear&&e.clear()),this.fsQuad.render(e)}}class v extends n{constructor({renderer:t,kernels:r=[0,1]}){super(),h.set(this,void 0),d.set(this,void 0),l.set(this,void 0),a(this,h,r,"f"),a(this,d,t,"f"),a(this,l,new o(t,new e(0,0)),"f"),this.setKernels(r)}getKernels(){return Array.from(f(this,h,"f"))}setKernels(e){const r=f(this,d,"f").getDrawingBufferSize(new t);for(const[s,n]of e.entries()){const e=(new t).setScalar(.5+n).divide(r),i=f(this,l,"f").passes[s];i?(i.uniforms.uOffset.value=e,i.shouldRenderToScreen=!1):f(this,l,"f").addPass(new c(e))}f(this,l,"f").passes.length=e.length,f(this,l,"f").reset(),a(this,h,Array.from(e),"f")}render(e,t,r){0!==f(this,h,"f").length&&(f(this,l,"f").readBuffer=r,f(this,l,"f").writeBuffer=t,f(this,l,"f").passes[f(this,l,"f").passes.length-1].shouldRenderToScreen=this.renderToScreen,f(this,l,"f").render())}setSize(e,t){f(this,l,"f").setSize(e,t),this.setKernels(f(this,h,"f"))}}h=new WeakMap,d=new WeakMap,l=new WeakMap;export{v as KawaseBlurPass,u as KawaseBlurShader};
//# sourceMappingURL=KawaseBlur.js.map
