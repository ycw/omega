import{Matrix4 as t,Vector3 as n,Vector2 as o,BufferGeometry as e,Mesh as s,Uint16BufferAttribute as i,Uint32BufferAttribute as r,BufferAttribute as l}from"three";function c(){this.polygons=[]}c.fromPolygons=function(t){var n=new c;return n.polygons=t,n},c.prototype={clone:function(){var t=new c;return t.polygons=this.polygons.map((function(t){return t.clone()})),t},toPolygons:function(){return this.polygons},union:function(t){var n=new c.Node(this.clone().polygons),o=new c.Node(t.clone().polygons);return n.clipTo(o),o.clipTo(n),o.invert(),o.clipTo(n),o.invert(),n.build(o.allPolygons()),c.fromPolygons(n.allPolygons())},subtract:function(t){var n=new c.Node(this.clone().polygons),o=new c.Node(t.clone().polygons);return n.invert(),n.clipTo(o),o.clipTo(n),o.invert(),o.clipTo(n),o.invert(),n.build(o.allPolygons()),n.invert(),c.fromPolygons(n.allPolygons())},intersect:function(t){var n=new c.Node(this.clone().polygons),o=new c.Node(t.clone().polygons);return n.invert(),o.clipTo(n),o.invert(),n.clipTo(o),o.clipTo(n),n.build(o.allPolygons()),n.invert(),c.fromPolygons(n.allPolygons())},inverse:function(){var t=this.clone();return t.polygons.map((function(t){t.flip()})),t}},c.Vector=function(t,n,o){3==arguments.length?(this.x=t,this.y=n,this.z=o):"x"in t?(this.x=t.x,this.y=t.y,this.z=t.z):(this.x=t[0],this.y=t[1],this.z=t[2])},c.Vector.prototype={clone:function(){return new c.Vector(this.x,this.y,this.z)},negated:function(){return new c.Vector(-this.x,-this.y,-this.z)},plus:function(t){return new c.Vector(this.x+t.x,this.y+t.y,this.z+t.z)},minus:function(t){return new c.Vector(this.x-t.x,this.y-t.y,this.z-t.z)},times:function(t){return new c.Vector(this.x*t,this.y*t,this.z*t)},dividedBy:function(t){return new c.Vector(this.x/t,this.y/t,this.z/t)},dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z},lerp:function(t,n){return this.plus(t.minus(this).times(n))},length:function(){return Math.sqrt(this.dot(this))},unit:function(){return this.dividedBy(this.length())},cross:function(t){return new c.Vector(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}},c.Vertex=function(t,n,o,e){this.pos=new c.Vector(t),this.normal=n&&new c.Vector(n),this.uv=o&&o.clone(),this.color=e&&new c.Vector(e)},c.Vertex.prototype={clone:function(){return new c.Vertex(this.pos.clone(),this.normal&&this.normal.clone(),this.uv&&this.uv.clone(),this.color&&this.color.clone())},flip:function(){this.normal&&(this.normal=this.normal.negated())},interpolate:function(t,n){return new c.Vertex(this.pos.lerp(t.pos,n),this.normal&&t.normal&&this.normal.lerp(t.normal,n),this.uv&&t.uv&&this.uv.clone().lerp(t.uv,n),this.color&&t.color&&this.color.lerp(t.color,n))}},c.Plane=function(t,n){this.normal=t,this.w=n},c.Plane.EPSILON=1e-5,c.Plane.fromPoints=function(t,n,o){var e=n.minus(t).cross(o.minus(t)).unit();return new c.Plane(e,e.dot(t))},c.Plane.prototype={clone:function(){return new c.Plane(this.normal.clone(),this.w)},flip:function(){this.normal=this.normal.negated(),this.w=-this.w},splitPolygon:function(t,n,o,e,s){for(var i=0,r=[],l=0;l<t.vertices.length;l++){var h=(m=this.normal.dot(t.vertices[l].pos)-this.w)<-c.Plane.EPSILON?2:m>c.Plane.EPSILON?1:0;i|=h,r.push(h)}switch(i){case 0:(this.normal.dot(t.plane.normal)>0?n:o).push(t);break;case 1:e.push(t);break;case 2:s.push(t);break;case 3:var a=[],u=[];for(l=0;l<t.vertices.length;l++){var p=(l+1)%t.vertices.length,f=r[l],y=r[p],g=t.vertices[l],w=t.vertices[p];if(2!=f&&a.push(g),1!=f&&u.push(2!=f?g.clone():g),3==(f|y)){var m=(this.w-this.normal.dot(g.pos))/this.normal.dot(w.pos.minus(g.pos)),v=g.interpolate(w,m);a.push(v),u.push(v.clone())}}a.length>=3&&e.push(new c.Polygon(a,t.shared)),u.length>=3&&s.push(new c.Polygon(u,t.shared))}}},c.Polygon=function(t,n){this.vertices=t,this.shared=n,this.plane=c.Plane.fromPoints(t[0].pos,t[1].pos,t[2].pos)},c.Polygon.prototype={clone:function(){var t=this.vertices.map((function(t){return t.clone()}));return new c.Polygon(t,this.shared)},flip:function(){this.vertices.reverse().map((function(t){t.flip()})),this.plane.flip()}},c.Node=function(t){this.plane=null,this.front=null,this.back=null,this.polygons=[],t&&this.build(t)},c.Node.prototype={clone:function(){var t=new c.Node;return t.plane=this.plane&&this.plane.clone(),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t.polygons=this.polygons.map((function(t){return t.clone()})),t},invert:function(){for(var t=0;t<this.polygons.length;t++)this.polygons[t].flip();this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();var n=this.front;this.front=this.back,this.back=n},clipPolygons:function(t){if(!this.plane)return t.slice();for(var n=[],o=[],e=0;e<t.length;e++)this.plane.splitPolygon(t[e],n,o,n,o);return this.front&&(n=this.front.clipPolygons(n)),o=this.back?this.back.clipPolygons(o):[],n.concat(o)},clipTo:function(t){this.polygons=t.clipPolygons(this.polygons),this.front&&this.front.clipTo(t),this.back&&this.back.clipTo(t)},allPolygons:function(){var t=this.polygons.slice();return this.front&&(t=t.concat(this.front.allPolygons())),this.back&&(t=t.concat(this.back.allPolygons())),t},build:function(t){if(t.length){this.plane||(this.plane=t[0].plane.clone());for(var n=[],o=[],e=0;e<t.length;e++)this.plane.splitPolygon(t[e],this.polygons,this.polygons,n,o);n.length&&(this.front||(this.front=new c.Node),this.front.build(n)),o.length&&(this.back||(this.back=new c.Node),this.back.build(o))}}};class h{#t;constructor(t){this.#t=t instanceof c?t:u(t)}subtract(t){return new h(this.#t.subtract(t instanceof h?t.#t:u(t)))}intersect(t){return new h(this.#t.intersect(t instanceof h?t.#t:u(t)))}union(t){return new h(this.#t.union(t instanceof h?t.#t:u(t)))}toMesh(){return function(t){const n=t.toPolygons(),o=new Map;let c=0;for(const{vertices:t,shared:e}of n)o.has(e)?o.get(e).push(t):o.set(e,[t]),c+=t.length;const h=new Float32Array(3*c),a=new Float32Array(3*c),u=new Float32Array(2*c),p=new Float32Array(3*c),f=new e,y=[],g=new s(f,y);let w,m,v,d=0,P=0,b=0,x=0,z=0,k=0,V=0;const A=[];let N=0;for(const[t,n]of o.entries()){P=0;for(const t of n){for(let n=1,o=t.length-1;n<o;++n)A.push(N,N+n,N+n+1);N+=t.length,P+=3*(t.length-2);for(const{pos:n,normal:o,uv:e,color:s}of t)h[x++]=n.x,h[x++]=n.y,h[x++]=n.z,w||(w=o),o?(a[z++]=o.x,a[z++]=o.y,a[z++]=o.z):z+=3,m||(m=e),e?(u[k++]=e.x,u[k++]=e.y):k+=2,v||(v=s),s?(p[V++]=s.x,p[V++]=s.y,p[V++]=s.z):V+=3}y.push(t),f.addGroup(d,P,b),d+=P,b+=1}N<=65535?f.index=new i(A,1):(console.warn("index > 65535"),f.index=new r(A,1));f.setAttribute("position",new l(h,3)),w&&f.setAttribute("normal",new l(a,3));m&&f.setAttribute("uv",new l(u,2));v&&f.setAttribute("color",new l(p,3));return g}(this.#t)}}function a(t){return new h(t)}function u(e){return c.fromPolygons(function(e){const s=e.clone();s.updateMatrix();const{matrix:i}=s,r=!i.equals(new t),l=[],h=e.geometry.attributes.position.array,{normal:a,uv:u,color:p}=e.geometry.attributes,f=a&&a.array,y=u&&u.array,g=p&&p.array,w=e.geometry.index&&e.geometry.index.array,m=w?w.length:h.length/3,v=Array.isArray(e.material)?e.geometry.groups:[{start:0,count:m,materialIndex:0}];for(const{start:t,count:s,materialIndex:a}of v){const u=Array.isArray(e.material)?e.material[a??0]:e.material;for(let e=t;e<t+s;e+=3){const t=[];for(let s=0;s<3;++s){const l=w?w[e+s]:e+s;t.push(new c.Vertex(r?(new n).fromArray(h,3*l).applyMatrix4(i):h.subarray(3*l,3*l+3),f&&f.subarray(3*l,3*l+3),y&&(new o).fromArray(y,2*l),g&&g.subarray(3*l,3*l+3)))}l.push(new c.Polygon(t,u))}}return l}(e))}export{a as CSG};
//# sourceMappingURL=CSG.js.map
