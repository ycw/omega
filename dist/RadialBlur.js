import{Vector2 as e,ShaderMaterial as t,UniformsUtils as n}from"three";import{Pass as r,FullScreenQuad as i}from"three/examples/jsm/postprocessing/Pass.js";function a(e,t,n,r){if("a"===n&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?r:"a"===n?r.call(e):r?r.value:t.get(e)}function s(e,t,n,r,i){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?i.call(e,n):i?i.value=n:t.set(e,n),n}const o={defines:{MAX_ITERATIONS:100},uniforms:{tDiffuse:{value:null},uRadialCenter:{value:null},uIntensity:{value:1},uIterations:{value:10}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 uRadialCenter;\n    uniform float uIntensity;\n    uniform float uIterations;\n    varying vec2 vUv;\n    void main() {\n      vec2 v = uIntensity * ( uRadialCenter * .5 + .5 - vUv );\n      const float MAX_I = float( MAX_ITERATIONS );\n      float I = max( 1., min( uIterations, MAX_I ) );\n      for ( float i = 0. ; i < MAX_I ; i++ ) {\n        if ( i >= uIterations ) break;\n        gl_FragColor += texture2D( tDiffuse, vUv + v * i / I );\n      }\n      gl_FragColor /= I;\n    }\n  "};var u,f,l;class v extends r{constructor({intensity:r=1,iterations:a=10,maxIterations:v=100,radialCenter:d=new e}={}){super(),u.set(this,void 0),f.set(this,void 0),l.set(this,void 0);const h=new t({defines:{...o.defines,MAX_ITERATIONS:v},uniforms:n.merge([o.uniforms,{uRadialCenter:{value:d},uIntensity:{value:r},uIterations:{value:a}}]),vertexShader:o.vertexShader,fragmentShader:o.fragmentShader});s(this,u,new i(h),"f"),s(this,f,h.uniforms,"f"),s(this,l,h.defines,"f")}render(e,t,n){a(this,f,"f").tDiffuse.value=n.texture,this.renderToScreen?e.setRenderTarget(null):(e.setRenderTarget(t),this.clear&&e.clear()),a(this,u,"f").render(e)}get iterations(){return a(this,f,"f").uIterations.value}set iterations(e){e>a(this,l,"f").MAX_ITERATIONS&&console.warn(`iterations (${e}) will be capped by maxIterations (${a(this,l,"f").MAX_ITERATIONS}) in shader`),a(this,f,"f").uIterations.value=e}get intensity(){return a(this,f,"f").uIntensity.value}set intensity(e){a(this,f,"f").uIntensity.value=e}get radialCenter(){return a(this,f,"f").uRadialCenter.value}set radialCenter(e){a(this,f,"f").uRadialCenter.value=e}get maxIterations(){return a(this,l,"f").MAX_ITERATIONS}}u=new WeakMap,f=new WeakMap,l=new WeakMap;export{v as RadialBlurPass,o as RadialBlurShader};
//# sourceMappingURL=RadialBlur.js.map
