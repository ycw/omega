import{Vector2 as e,ShaderMaterial as n,UniformsUtils as t}from"three";import{Pass as i,FullScreenQuad as r}from"three/examples/jsm/postprocessing/Pass.js";const s={defines:{MAX_ITERATIONS:100},uniforms:{tDiffuse:{value:null},uRadialCenter:{value:null},uIntensity:{value:1},uIterations:{value:10}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 uRadialCenter;\n    uniform float uIntensity;\n    uniform float uIterations;\n    varying vec2 vUv;\n    void main() {\n      vec2 v = uIntensity * ( uRadialCenter * .5 + .5 - vUv );\n      const float MAX_I = float( MAX_ITERATIONS );\n      float I = max( 1., min( uIterations, MAX_I ) );\n      for ( float i = 0. ; i < MAX_I ; i++ ) {\n        if ( i >= uIterations ) break;\n        gl_FragColor += texture2D( tDiffuse, vUv + v * i / I );\n      }\n      gl_FragColor /= I;\n    }\n  "};class a extends i{#e;#n;#t;constructor({intensity:i=1,iterations:a=10,maxIterations:u=100,radialCenter:o=new e}={}){super();const f=new n({defines:{...s.defines,MAX_ITERATIONS:u},uniforms:t.merge([s.uniforms,{uRadialCenter:{value:o},uIntensity:{value:i},uIterations:{value:a}}]),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader});this.#e=new r(f),this.#n=f.uniforms,this.#t=f.defines}render(e,n,t){this.#n.tDiffuse.value=t.texture,this.renderToScreen?e.setRenderTarget(null):(e.setRenderTarget(n),this.clear&&e.clear()),this.#e.render(e)}get iterations(){return this.#n.uIterations.value}set iterations(e){e>this.#t.MAX_ITERATIONS&&console.warn(`iterations (${e}) will be capped by maxIterations (${this.#t.MAX_ITERATIONS}) in shader`),this.#n.uIterations.value=e}get intensity(){return this.#n.uIntensity.value}set intensity(e){this.#n.uIntensity.value=e}get radialCenter(){return this.#n.uRadialCenter.value}set radialCenter(e){this.#n.uRadialCenter.value=e}get maxIterations(){return this.#t.MAX_ITERATIONS}}export{a as RadialBlurPass,s as RadialBlurShader};
//# sourceMappingURL=RadialBlur.js.map
