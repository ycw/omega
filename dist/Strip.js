import{Vector3 as t,BufferGeometry as s,Float32BufferAttribute as e,LineSegments as r,LineBasicMaterial as o,Color as i,BufferAttribute as a}from"three";class n{constructor(t,s=1,e=0){this.curve=t,this.radius=s,this.tilt=e}computeFrames(s){const e=new t,r=new t,o=new t,i=new t,a=new t,n=new t,l=new t,h=new t,c=[],p=this.tilt instanceof Function?this.tilt:()=>this.tilt,u=(t,s)=>{c[t]=[],c[t][0]=r.clone(),c[t][1]=o.clone(),c[t][2]=e.clone(),c[t][3]=this.curve.getPointAt(t/s);const i=p(t,s);i&&c[t][0].applyAxisAngle(e,i),i&&c[t][1].applyAxisAngle(e,i)};this.curve.getTangentAt(0,e),h.set(Math.abs(e.x),Math.abs(e.y),Math.abs(e.z)),l.set(1,0,0),h.y<=h.x?h.z<=h.y?l.set(0,0,1):l.set(0,1,0):h.z<=h.x&&l.set(0,0,1),h.crossVectors(e,l).normalize(),r.crossVectors(e,h),o.crossVectors(e,r),u(0,s);for(let t=1,l=NaN;t<=s;++t)l=t/s,this.curve.getTangentAt(l,i),a.copy(r),h.crossVectors(e,i).length()>Number.EPSILON&&a.applyAxisAngle(h.normalize(),Math.acos(Math.max(-1,Math.min(1,e.dot(i))))),n.crossVectors(i,a),e.copy(i),o.copy(n),r.copy(a),u(t,s);return c}}var l,h;class c extends s{constructor(t,s,e){super(),l.add(this),function(t,s,e,r){if("a"===e&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof s?t!==s||!r:!s.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===e?r:"a"===e?r.call(t):r?r.value:s.get(t)}(this,l,"m",h).call(this,t,c.parseSegments(s),e)}static parseSegments(t){const s=[];return Array.isArray(t)?(s[0]=t[0],s[1]=void 0===t[1]?[t[0]]:t[1],s[2]=t[2]||0):(s[0]=t,s[1]=[t],s[2]=0),s[0]=Math.max(1,0|s[0]),s[1]=s[1].filter((t=>t>=1)).map((t=>0|t)),s[1].length||(s[1]=[s[0]]),s[1].length%2&&s[1].push(...s[1]),s[2]|=0,s}}l=new WeakSet,h=function(s,[r,o,i],a){const n=[],l=[],h=[],c=o.flatMap(((t,s)=>Array(t).fill(1-s%2))),p=o.flatMap((t=>Array.from(Array(t).keys()))),u=o.flatMap((t=>Array(t).fill(t))),y=s.computeFrames(r),m=s.radius instanceof Function?s.radius:()=>s.radius,d=new t,x=new t,w=c.length;for(let t,s,e,o=0,g=0;o<r;){if(t=(i+o)%w,s=t<0?w+t:t,t=u[s]-p[s],e=o+t>r?r-o:t,c[s]){for(let t,i,c,w,f=0;f<=e;++f)[t,,,i]=y[o+f],c=m(o+f,r),d.copy(t).multiplyScalar(c).add(i),x.copy(t).multiplyScalar(-c).add(i),l.push(d.x,d.y,d.z,x.x,x.y,x.z),a&&h.push(...a(f<e?p[s+f]:p[s+f-1]+1,u[s],o+f,r)),f<e&&n.push(w=2*f+g,w+1,w+2,w+2,w+1,w+3);g+=2*(e+1)}o+=e}this.attributes.position=new e(l,3),a&&(this.attributes.uv=new e(h,2)),this.setIndex(n),this.computeVertexNormals()};class p extends r{constructor(t,e,r=1,a=16711680,n=65280,l=255){super(new s,new o({vertexColors:!0})),this.strip=t,this.segments=e,this.size=r,this.type="StripHelper",this.xColor=new i(a),this.yColor=new i(n),this.zColor=new i(l),this.update()}update(){const t=Math.max(1,0|this.segments),s=Math.max(0,this.size),e=this.strip.computeFrames(t),r=new Float32Array(18*e.length),o=new Float32Array(18*e.length);this.geometry.dispose(),this.geometry.attributes.position=new a(r,3),this.geometry.attributes.color=new a(o,3);for(const[t,[i,a,n,l]]of e.entries())i.multiplyScalar(s).add(l),a.multiplyScalar(s).add(l),n.multiplyScalar(s).add(l),r.set([l.x,l.y,l.z,i.x,i.y,i.z,l.x,l.y,l.z,a.x,a.y,a.z,l.x,l.y,l.z,n.x,n.y,n.z],18*t),o.set([this.xColor.r,this.xColor.g,this.xColor.b,this.xColor.r,this.xColor.g,this.xColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.zColor.r,this.zColor.g,this.zColor.b,this.zColor.r,this.zColor.g,this.zColor.b],18*t)}}function u(t,s){switch(s){case 0:return[0,t,1,t];case 1:return[t,1,t,0];case 2:return[1,t,0,t];case 3:return[t,0,t,1]}}class y{}y.dash=[(t,s)=>u(t/s,0),(t,s)=>u(t/s,1),(t,s)=>u(1-t/s,2),(t,s)=>u(1-t/s,3)],y.strip=[(t,s,e,r)=>u(e/r,0),(t,s,e,r)=>u(e/r,1),(t,s,e,r)=>u(1-e/r,2),(t,s,e,r)=>u(1-e/r,3)];export{n as Strip,c as StripGeometry,p as StripHelper,y as UvPreset};
//# sourceMappingURL=Strip.js.map
