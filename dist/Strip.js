import{Vector3 as t,BufferGeometry as s,Float32BufferAttribute as e,LineSegments as r,LineBasicMaterial as o,Color as i,BufferAttribute as a}from"three";class l{curve;radius;tilt;constructor(t,s=1,e=0){this.curve=t,this.radius=s,this.tilt=e}computeFrames(s){const e=new t,r=new t,o=new t,i=new t,a=new t,l=new t,n=new t,h=new t,c=[],p=this.tilt instanceof Function?this.tilt:()=>this.tilt,u=(t,s)=>{c[t]=[],c[t][0]=r.clone(),c[t][1]=o.clone(),c[t][2]=e.clone(),c[t][3]=this.curve.getPointAt(t/s);const i=p(t,s);i&&c[t][0].applyAxisAngle(e,i),i&&c[t][1].applyAxisAngle(e,i)};this.curve.getTangentAt(0,e),h.set(Math.abs(e.x),Math.abs(e.y),Math.abs(e.z)),n.set(1,0,0),h.y<=h.x?h.z<=h.y?n.set(0,0,1):n.set(0,1,0):h.z<=h.x&&n.set(0,0,1),h.crossVectors(e,n).normalize(),r.crossVectors(e,h),o.crossVectors(e,r),u(0,s);for(let t=1,n=NaN;t<=s;++t)n=t/s,this.curve.getTangentAt(n,i),a.copy(r),h.crossVectors(e,i).length()>Number.EPSILON&&a.applyAxisAngle(h.normalize(),Math.acos(Math.max(-1,Math.min(1,e.dot(i))))),l.crossVectors(i,a),e.copy(i),o.copy(l),r.copy(a),u(t,s);return c}}class n extends s{constructor(t,s,e){super(),this.#t(t,n.parseSegments(s),e)}static parseSegments(t){const s=[];return Array.isArray(t)?(s[0]=t[0],s[1]=void 0===t[1]?[t[0]]:t[1],s[2]=t[2]||0):(s[0]=t,s[1]=[t],s[2]=0),s[0]=Math.max(1,0|s[0]),s[1]=s[1].filter((t=>t>=1)).map((t=>0|t)),s[1].length||(s[1]=[s[0]]),s[1].length%2&&s[1].push(...s[1]),s[2]|=0,s}#t(s,[r,o,i],a){const l=[],n=[],h=[],c=o.flatMap(((t,s)=>Array(t).fill(1-s%2))),p=o.flatMap((t=>Array.from(Array(t).keys()))),u=o.flatMap((t=>Array(t).fill(t))),y=s.computeFrames(r),m=s.radius instanceof Function?s.radius:()=>s.radius,x=new t,g=new t,C=c.length;for(let t,s,e,o=0,d=0;o<r;){if(t=(i+o)%C,s=t<0?C+t:t,t=u[s]-p[s],e=o+t>r?r-o:t,c[s]){for(let t,i,c,C,z=0;z<=e;++z)[t,,,i]=y[o+z],c=m(o+z,r),x.copy(t).multiplyScalar(c).add(i),g.copy(t).multiplyScalar(-c).add(i),n.push(x.x,x.y,x.z,g.x,g.y,g.z),a&&h.push(...a(z<e?p[s+z]:p[s+z-1]+1,u[s],o+z,r)),z<e&&l.push(C=2*z+d,C+1,C+2,C+2,C+1,C+3);d+=2*(e+1)}o+=e}this.attributes.position=new e(n,3),a&&(this.attributes.uv=new e(h,2)),this.setIndex(l),this.computeVertexNormals()}}class h extends r{strip;segments;size;xColor;yColor;zColor;constructor(t,e,r=1,a=16711680,l=65280,n=255){super(new s,new o({vertexColors:!0})),this.strip=t,this.segments=e,this.size=r,this.type="StripHelper",this.xColor=new i(a),this.yColor=new i(l),this.zColor=new i(n),this.update()}update(){const t=Math.max(1,0|this.segments),s=Math.max(0,this.size),e=this.strip.computeFrames(t),r=new Float32Array(18*e.length),o=new Float32Array(18*e.length);this.geometry.dispose(),this.geometry.attributes.position=new a(r,3),this.geometry.attributes.color=new a(o,3);for(const[t,[i,a,l,n]]of e.entries())i.multiplyScalar(s).add(n),a.multiplyScalar(s).add(n),l.multiplyScalar(s).add(n),r.set([n.x,n.y,n.z,i.x,i.y,i.z,n.x,n.y,n.z,a.x,a.y,a.z,n.x,n.y,n.z,l.x,l.y,l.z],18*t),o.set([this.xColor.r,this.xColor.g,this.xColor.b,this.xColor.r,this.xColor.g,this.xColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.zColor.r,this.zColor.g,this.zColor.b,this.zColor.r,this.zColor.g,this.zColor.b],18*t)}}function c(t,s){switch(s){case 0:return[0,t,1,t];case 1:return[t,1,t,0];case 2:return[1,t,0,t];case 3:return[t,0,t,1]}}class p{static dash=[(t,s)=>c(t/s,0),(t,s)=>c(t/s,1),(t,s)=>c(1-t/s,2),(t,s)=>c(1-t/s,3)];static strip=[(t,s,e,r)=>c(e/r,0),(t,s,e,r)=>c(e/r,1),(t,s,e,r)=>c(1-e/r,2),(t,s,e,r)=>c(1-e/r,3)]}export{l as Strip,n as StripGeometry,h as StripHelper,p as UvPreset};
//# sourceMappingURL=Strip.js.map
