{"version":3,"file":"CSG.js","sources":["../node_modules/tslib/tslib.es6.js","../src/CSG/lib/csg/index.js","../src/CSG/CSG.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","// Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean\r\n// operations like union and intersection to combine 3D solids. This library\r\n// implements CSG operations on meshes elegantly and concisely using BSP trees,\r\n// and is meant to serve as an easily understandable implementation of the\r\n// algorithm. All edge cases involving overlapping coplanar polygons in both\r\n// solids are correctly handled.\r\n// \r\n// Example usage:\r\n// \r\n//     var cube = CSG.cube();\r\n//     var sphere = CSG.sphere({ radius: 1.3 });\r\n//     var polygons = cube.subtract(sphere).toPolygons();\r\n// \r\n// ## Implementation Details\r\n// \r\n// All CSG operations are implemented in terms of two functions, `clipTo()` and\r\n// `invert()`, which remove parts of a BSP tree inside another BSP tree and swap\r\n// solid and empty space, respectively. To find the union of `a` and `b`, we\r\n// want to remove everything in `a` inside `b` and everything in `b` inside `a`,\r\n// then combine polygons from `a` and `b` into one solid:\r\n// \r\n//     a.clipTo(b);\r\n//     b.clipTo(a);\r\n//     a.build(b.allPolygons());\r\n// \r\n// The only tricky part is handling overlapping coplanar polygons in both trees.\r\n// The code above keeps both copies, but we need to keep them in one tree and\r\n// remove them in the other tree. To remove them from `b` we can clip the\r\n// inverse of `b` against `a`. The code for union now looks like this:\r\n// \r\n//     a.clipTo(b);\r\n//     b.clipTo(a);\r\n//     b.invert();\r\n//     b.clipTo(a);\r\n//     b.invert();\r\n//     a.build(b.allPolygons());\r\n// \r\n// Subtraction and intersection naturally follow from set operations. If\r\n// union is `A | B`, subtraction is `A - B = ~(~A | B)` and intersection is\r\n// `A & B = ~(~A | ~B)` where `~` is the complement operator.\r\n// \r\n// ## License\r\n// \r\n// Copyright (c) 2011 Evan Wallace (http://madebyevan.com/), under the MIT license.\r\n\r\n// # class CSG\r\n\r\n// Holds a binary space partition tree representing a 3D solid. Two solids can\r\n// be combined using the `union()`, `subtract()`, and `intersect()` methods.\r\n\r\nexport function CSG() {\r\n  this.polygons = [];\r\n};\r\n\r\n// Construct a CSG solid from a list of `CSG.Polygon` instances.\r\nCSG.fromPolygons = function (polygons) {\r\n  var csg = new CSG();\r\n  csg.polygons = polygons;\r\n  return csg;\r\n};\r\n\r\nCSG.prototype = {\r\n  clone: function () {\r\n    var csg = new CSG();\r\n    csg.polygons = this.polygons.map(function (p) { return p.clone(); });\r\n    return csg;\r\n  },\r\n\r\n  toPolygons: function () {\r\n    return this.polygons;\r\n  },\r\n\r\n  // Return a new CSG solid representing space in either this solid or in the\r\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\r\n  // \r\n  //     A.union(B)\r\n  // \r\n  //     +-------+            +-------+\r\n  //     |       |            |       |\r\n  //     |   A   |            |       |\r\n  //     |    +--+----+   =   |       +----+\r\n  //     +----+--+    |       +----+       |\r\n  //          |   B   |            |       |\r\n  //          |       |            |       |\r\n  //          +-------+            +-------+\r\n  // \r\n  union: function (csg) {\r\n    var a = new CSG.Node(this.clone().polygons);\r\n    var b = new CSG.Node(csg.clone().polygons);\r\n    a.clipTo(b);\r\n    b.clipTo(a);\r\n    b.invert();\r\n    b.clipTo(a);\r\n    b.invert();\r\n    a.build(b.allPolygons());\r\n    return CSG.fromPolygons(a.allPolygons());\r\n  },\r\n\r\n  // Return a new CSG solid representing space in this solid but not in the\r\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\r\n  // \r\n  //     A.subtract(B)\r\n  // \r\n  //     +-------+            +-------+\r\n  //     |       |            |       |\r\n  //     |   A   |            |       |\r\n  //     |    +--+----+   =   |    +--+\r\n  //     +----+--+    |       +----+\r\n  //          |   B   |\r\n  //          |       |\r\n  //          +-------+\r\n  // \r\n  subtract: function (csg) {\r\n    var a = new CSG.Node(this.clone().polygons);\r\n    var b = new CSG.Node(csg.clone().polygons);\r\n    a.invert();\r\n    a.clipTo(b);\r\n    b.clipTo(a);\r\n    b.invert();\r\n    b.clipTo(a);\r\n    b.invert();\r\n    a.build(b.allPolygons());\r\n    a.invert();\r\n    return CSG.fromPolygons(a.allPolygons());\r\n  },\r\n\r\n  // Return a new CSG solid representing space both this solid and in the\r\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\r\n  // \r\n  //     A.intersect(B)\r\n  // \r\n  //     +-------+\r\n  //     |       |\r\n  //     |   A   |\r\n  //     |    +--+----+   =   +--+\r\n  //     +----+--+    |       +--+\r\n  //          |   B   |\r\n  //          |       |\r\n  //          +-------+\r\n  // \r\n  intersect: function (csg) {\r\n    var a = new CSG.Node(this.clone().polygons);\r\n    var b = new CSG.Node(csg.clone().polygons);\r\n    a.invert();\r\n    b.clipTo(a);\r\n    b.invert();\r\n    a.clipTo(b);\r\n    b.clipTo(a);\r\n    a.build(b.allPolygons());\r\n    a.invert();\r\n    return CSG.fromPolygons(a.allPolygons());\r\n  },\r\n\r\n  // Return a new CSG solid with solid and empty space switched. This solid is\r\n  // not modified.\r\n  inverse: function () {\r\n    var csg = this.clone();\r\n    csg.polygons.map(function (p) { p.flip(); });\r\n    return csg;\r\n  }\r\n};\r\n\r\n// // Construct an axis-aligned solid cuboid. Optional parameters are `center` and\r\n// // `radius`, which default to `[0, 0, 0]` and `[1, 1, 1]`. The radius can be\r\n// // specified using a single number or a list of three numbers, one for each axis.\r\n// // \r\n// // Example code:\r\n// // \r\n// //     var cube = CSG.cube({\r\n// //       center: [0, 0, 0],\r\n// //       radius: 1\r\n// //     });\r\n// CSG.cube = function(options) {\r\n//   options = options || {};\r\n//   var c = new CSG.Vector(options.center || [0, 0, 0]);\r\n//   var r = !options.radius ? [1, 1, 1] : options.radius.length ?\r\n//            options.radius : [options.radius, options.radius, options.radius];\r\n//   return CSG.fromPolygons([\r\n//     [[0, 4, 6, 2], [-1, 0, 0]],\r\n//     [[1, 3, 7, 5], [+1, 0, 0]],\r\n//     [[0, 1, 5, 4], [0, -1, 0]],\r\n//     [[2, 6, 7, 3], [0, +1, 0]],\r\n//     [[0, 2, 3, 1], [0, 0, -1]],\r\n//     [[4, 5, 7, 6], [0, 0, +1]]\r\n//   ].map(function(info) {\r\n//     return new CSG.Polygon(info[0].map(function(i) {\r\n//       var pos = new CSG.Vector(\r\n//         c.x + r[0] * (2 * !!(i & 1) - 1),\r\n//         c.y + r[1] * (2 * !!(i & 2) - 1),\r\n//         c.z + r[2] * (2 * !!(i & 4) - 1)\r\n//       );\r\n//       return new CSG.Vertex(pos, new CSG.Vector(info[1]));\r\n//     }));\r\n//   }));\r\n// };\r\n\r\n// // Construct a solid sphere. Optional parameters are `center`, `radius`,\r\n// // `slices`, and `stacks`, which default to `[0, 0, 0]`, `1`, `16`, and `8`.\r\n// // The `slices` and `stacks` parameters control the tessellation along the\r\n// // longitude and latitude directions.\r\n// // \r\n// // Example usage:\r\n// // \r\n// //     var sphere = CSG.sphere({\r\n// //       center: [0, 0, 0],\r\n// //       radius: 1,\r\n// //       slices: 16,\r\n// //       stacks: 8\r\n// //     });\r\n// CSG.sphere = function(options) {\r\n//   options = options || {};\r\n//   var c = new CSG.Vector(options.center || [0, 0, 0]);\r\n//   var r = options.radius || 1;\r\n//   var slices = options.slices || 16;\r\n//   var stacks = options.stacks || 8;\r\n//   var polygons = [], vertices;\r\n//   function vertex(theta, phi) {\r\n//     theta *= Math.PI * 2;\r\n//     phi *= Math.PI;\r\n//     var dir = new CSG.Vector(\r\n//       Math.cos(theta) * Math.sin(phi),\r\n//       Math.cos(phi),\r\n//       Math.sin(theta) * Math.sin(phi)\r\n//     );\r\n//     vertices.push(new CSG.Vertex(c.plus(dir.times(r)), dir));\r\n//   }\r\n//   for (var i = 0; i < slices; i++) {\r\n//     for (var j = 0; j < stacks; j++) {\r\n//       vertices = [];\r\n//       vertex(i / slices, j / stacks);\r\n//       if (j > 0) vertex((i + 1) / slices, j / stacks);\r\n//       if (j < stacks - 1) vertex((i + 1) / slices, (j + 1) / stacks);\r\n//       vertex(i / slices, (j + 1) / stacks);\r\n//       polygons.push(new CSG.Polygon(vertices));\r\n//     }\r\n//   }\r\n//   return CSG.fromPolygons(polygons);\r\n// };\r\n\r\n// // Construct a solid cylinder. Optional parameters are `start`, `end`,\r\n// // `radius`, and `slices`, which default to `[0, -1, 0]`, `[0, 1, 0]`, `1`, and\r\n// // `16`. The `slices` parameter controls the tessellation.\r\n// // \r\n// // Example usage:\r\n// // \r\n// //     var cylinder = CSG.cylinder({\r\n// //       start: [0, -1, 0],\r\n// //       end: [0, 1, 0],\r\n// //       radius: 1,\r\n// //       slices: 16\r\n// //     });\r\n// CSG.cylinder = function(options) {\r\n//   options = options || {};\r\n//   var s = new CSG.Vector(options.start || [0, -1, 0]);\r\n//   var e = new CSG.Vector(options.end || [0, 1, 0]);\r\n//   var ray = e.minus(s);\r\n//   var r = options.radius || 1;\r\n//   var slices = options.slices || 16;\r\n//   var axisZ = ray.unit(), isY = (Math.abs(axisZ.y) > 0.5);\r\n//   var axisX = new CSG.Vector(isY, !isY, 0).cross(axisZ).unit();\r\n//   var axisY = axisX.cross(axisZ).unit();\r\n//   var start = new CSG.Vertex(s, axisZ.negated());\r\n//   var end = new CSG.Vertex(e, axisZ.unit());\r\n//   var polygons = [];\r\n//   function point(stack, slice, normalBlend) {\r\n//     var angle = slice * Math.PI * 2;\r\n//     var out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));\r\n//     var pos = s.plus(ray.times(stack)).plus(out.times(r));\r\n//     var normal = out.times(1 - Math.abs(normalBlend)).plus(axisZ.times(normalBlend));\r\n//     return new CSG.Vertex(pos, normal);\r\n//   }\r\n//   for (var i = 0; i < slices; i++) {\r\n//     var t0 = i / slices, t1 = (i + 1) / slices;\r\n//     polygons.push(new CSG.Polygon([start, point(0, t0, -1), point(0, t1, -1)]));\r\n//     polygons.push(new CSG.Polygon([point(0, t1, 0), point(0, t0, 0), point(1, t0, 0), point(1, t1, 0)]));\r\n//     polygons.push(new CSG.Polygon([end, point(1, t1, 1), point(1, t0, 1)]));\r\n//   }\r\n//   return CSG.fromPolygons(polygons);\r\n// };\r\n\r\n// # class Vector\r\n\r\n// Represents a 3D vector.\r\n// \r\n// Example usage:\r\n// \r\n//     new CSG.Vector(1, 2, 3);\r\n//     new CSG.Vector([1, 2, 3]);\r\n//     new CSG.Vector({ x: 1, y: 2, z: 3 });\r\n\r\nCSG.Vector = function (x, y, z) {\r\n  if (arguments.length == 3) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n  } else if ('x' in x) {\r\n    this.x = x.x;\r\n    this.y = x.y;\r\n    this.z = x.z;\r\n  } else {\r\n    this.x = x[0];\r\n    this.y = x[1];\r\n    this.z = x[2];\r\n  }\r\n};\r\n\r\nCSG.Vector.prototype = {\r\n  clone: function () {\r\n    return new CSG.Vector(this.x, this.y, this.z);\r\n  },\r\n\r\n  negated: function () {\r\n    return new CSG.Vector(-this.x, -this.y, -this.z);\r\n  },\r\n\r\n  plus: function (a) {\r\n    return new CSG.Vector(this.x + a.x, this.y + a.y, this.z + a.z);\r\n  },\r\n\r\n  minus: function (a) {\r\n    return new CSG.Vector(this.x - a.x, this.y - a.y, this.z - a.z);\r\n  },\r\n\r\n  times: function (a) {\r\n    return new CSG.Vector(this.x * a, this.y * a, this.z * a);\r\n  },\r\n\r\n  dividedBy: function (a) {\r\n    return new CSG.Vector(this.x / a, this.y / a, this.z / a);\r\n  },\r\n\r\n  dot: function (a) {\r\n    return this.x * a.x + this.y * a.y + this.z * a.z;\r\n  },\r\n\r\n  lerp: function (a, t) {\r\n    return this.plus(a.minus(this).times(t));\r\n  },\r\n\r\n  length: function () {\r\n    return Math.sqrt(this.dot(this));\r\n  },\r\n\r\n  unit: function () {\r\n    return this.dividedBy(this.length());\r\n  },\r\n\r\n  cross: function (a) {\r\n    return new CSG.Vector(\r\n      this.y * a.z - this.z * a.y,\r\n      this.z * a.x - this.x * a.z,\r\n      this.x * a.y - this.y * a.x\r\n    );\r\n  }\r\n};\r\n\r\n// # class Vertex\r\n\r\n// Represents a vertex of a polygon. Use your own vertex class instead of this\r\n// one to provide additional features like texture coordinates and vertex\r\n// colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n// `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n// defined by `CSG.Vertex`. This class provides `normal` so convenience\r\n// functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n// is not used anywhere else.\r\n\r\nCSG.Vertex = function (pos, normal, uv, color) {\r\n  this.pos = new CSG.Vector(pos);\r\n  this.normal = normal && new CSG.Vector(normal);\r\n  this.uv = uv && uv.clone(); // uv is a `THREE.Vector2`.\r\n  this.color = color && new CSG.Vector(color);\r\n};\r\n\r\nCSG.Vertex.prototype = {\r\n  clone: function () {\r\n    return new CSG.Vertex(\r\n      this.pos.clone(),\r\n      this.normal && this.normal.clone(),\r\n      this.uv && this.uv.clone(),\r\n      this.color && this.color.clone()\r\n    );\r\n  },\r\n\r\n  // Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n  // orientation of a polygon is flipped.\r\n  flip: function () {\r\n    if (this.normal) {\r\n      this.normal = this.normal.negated();\r\n    }\r\n  },\r\n\r\n  // Create a new vertex between this vertex and `other` by linearly\r\n  // interpolating all properties using a parameter of `t`. Subclasses should\r\n  // override this to interpolate additional properties.\r\n  interpolate: function (other, t) {\r\n    return new CSG.Vertex(\r\n      this.pos.lerp(other.pos, t),\r\n      this.normal && other.normal && this.normal.lerp(other.normal, t),\r\n      this.uv && other.uv && this.uv.clone().lerp(other.uv, t),\r\n      this.color && other.color && this.color.lerp(other.color, t),\r\n    );\r\n  }\r\n};\r\n\r\n// # class Plane\r\n\r\n// Represents a plane in 3D space.\r\n\r\nCSG.Plane = function (normal, w) {\r\n  this.normal = normal;\r\n  this.w = w;\r\n};\r\n\r\n// `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n// point is on the plane.\r\nCSG.Plane.EPSILON = 1e-5;\r\n\r\nCSG.Plane.fromPoints = function (a, b, c) {\r\n  var n = b.minus(a).cross(c.minus(a)).unit();\r\n  return new CSG.Plane(n, n.dot(a));\r\n};\r\n\r\nCSG.Plane.prototype = {\r\n  clone: function () {\r\n    return new CSG.Plane(this.normal.clone(), this.w);\r\n  },\r\n\r\n  flip: function () {\r\n    this.normal = this.normal.negated();\r\n    this.w = -this.w;\r\n  },\r\n\r\n  // Split `polygon` by this plane if needed, then put the polygon or polygon\r\n  // fragments in the appropriate lists. Coplanar polygons go into either\r\n  // `coplanarFront` or `coplanarBack` depending on their orientation with\r\n  // respect to this plane. Polygons in front or in back of this plane go into\r\n  // either `front` or `back`.\r\n  splitPolygon: function (polygon, coplanarFront, coplanarBack, front, back) {\r\n    var COPLANAR = 0;\r\n    var FRONT = 1;\r\n    var BACK = 2;\r\n    var SPANNING = 3;\r\n\r\n    // Classify each point as well as the entire polygon into one of the above\r\n    // four classes.\r\n    var polygonType = 0;\r\n    var types = [];\r\n    for (var i = 0; i < polygon.vertices.length; i++) {\r\n      var t = this.normal.dot(polygon.vertices[i].pos) - this.w;\r\n      var type = (t < -CSG.Plane.EPSILON) ? BACK : (t > CSG.Plane.EPSILON) ? FRONT : COPLANAR;\r\n      polygonType |= type;\r\n      types.push(type);\r\n    }\r\n\r\n    // Put the polygon in the correct list, splitting it when necessary.\r\n    switch (polygonType) {\r\n      case COPLANAR:\r\n        (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n        break;\r\n      case FRONT:\r\n        front.push(polygon);\r\n        break;\r\n      case BACK:\r\n        back.push(polygon);\r\n        break;\r\n      case SPANNING:\r\n        var f = [], b = [];\r\n        for (var i = 0; i < polygon.vertices.length; i++) {\r\n          var j = (i + 1) % polygon.vertices.length;\r\n          var ti = types[i], tj = types[j];\r\n          var vi = polygon.vertices[i], vj = polygon.vertices[j];\r\n          if (ti != BACK) f.push(vi);\r\n          if (ti != FRONT) b.push(ti != BACK ? vi.clone() : vi);\r\n          if ((ti | tj) == SPANNING) {\r\n            var t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(vj.pos.minus(vi.pos));\r\n            var v = vi.interpolate(vj, t);\r\n            f.push(v);\r\n            b.push(v.clone());\r\n          }\r\n        }\r\n        if (f.length >= 3) front.push(new CSG.Polygon(f, polygon.shared));\r\n        if (b.length >= 3) back.push(new CSG.Polygon(b, polygon.shared));\r\n        break;\r\n    }\r\n  }\r\n};\r\n\r\n// # class Polygon\r\n\r\n// Represents a convex polygon. The vertices used to initialize a polygon must\r\n// be coplanar and form a convex loop. They do not have to be `CSG.Vertex`\r\n// instances but they must behave similarly (duck typing can be used for\r\n// customization).\r\n// \r\n// Each convex polygon has a `shared` property, which is shared between all\r\n// polygons that are clones of each other or were split from the same polygon.\r\n// This can be used to define per-polygon properties (such as surface color).\r\n\r\nCSG.Polygon = function (vertices, shared) {\r\n  this.vertices = vertices;\r\n  this.shared = shared;\r\n  this.plane = CSG.Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n};\r\n\r\nCSG.Polygon.prototype = {\r\n  clone: function () {\r\n    var vertices = this.vertices.map(function (v) { return v.clone(); });\r\n    return new CSG.Polygon(vertices, this.shared);\r\n  },\r\n\r\n  flip: function () {\r\n    this.vertices.reverse().map(function (v) { v.flip(); });\r\n    this.plane.flip();\r\n  }\r\n};\r\n\r\n// # class Node\r\n\r\n// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n// by picking a polygon to split along. That polygon (and all other coplanar\r\n// polygons) are added directly to that node and the other polygons are added to\r\n// the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n// no distinction between internal and leaf nodes.\r\n\r\nCSG.Node = function (polygons) {\r\n  this.plane = null;\r\n  this.front = null;\r\n  this.back = null;\r\n  this.polygons = [];\r\n  if (polygons) this.build(polygons);\r\n};\r\n\r\nCSG.Node.prototype = {\r\n  clone: function () {\r\n    var node = new CSG.Node();\r\n    node.plane = this.plane && this.plane.clone();\r\n    node.front = this.front && this.front.clone();\r\n    node.back = this.back && this.back.clone();\r\n    node.polygons = this.polygons.map(function (p) { return p.clone(); });\r\n    return node;\r\n  },\r\n\r\n  // Convert solid space to empty space and empty space to solid space.\r\n  invert: function () {\r\n    for (var i = 0; i < this.polygons.length; i++) {\r\n      this.polygons[i].flip();\r\n    }\r\n    this.plane.flip();\r\n    if (this.front) this.front.invert();\r\n    if (this.back) this.back.invert();\r\n    var temp = this.front;\r\n    this.front = this.back;\r\n    this.back = temp;\r\n  },\r\n\r\n  // Recursively remove all polygons in `polygons` that are inside this BSP\r\n  // tree.\r\n  clipPolygons: function (polygons) {\r\n    if (!this.plane) return polygons.slice();\r\n    var front = [], back = [];\r\n    for (var i = 0; i < polygons.length; i++) {\r\n      this.plane.splitPolygon(polygons[i], front, back, front, back);\r\n    }\r\n    if (this.front) front = this.front.clipPolygons(front);\r\n    if (this.back) back = this.back.clipPolygons(back);\r\n    else back = [];\r\n    return front.concat(back);\r\n  },\r\n\r\n  // Remove all polygons in this BSP tree that are inside the other BSP tree\r\n  // `bsp`.\r\n  clipTo: function (bsp) {\r\n    this.polygons = bsp.clipPolygons(this.polygons);\r\n    if (this.front) this.front.clipTo(bsp);\r\n    if (this.back) this.back.clipTo(bsp);\r\n  },\r\n\r\n  // Return a list of all polygons in this BSP tree.\r\n  allPolygons: function () {\r\n    var polygons = this.polygons.slice();\r\n    if (this.front) polygons = polygons.concat(this.front.allPolygons());\r\n    if (this.back) polygons = polygons.concat(this.back.allPolygons());\r\n    return polygons;\r\n  },\r\n\r\n  // Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n  // new polygons are filtered down to the bottom of the tree and become new\r\n  // nodes there. Each set of polygons is partitioned using the first polygon\r\n  // (no heuristic is used to pick a good split).\r\n  build: function (polygons) {\r\n    if (!polygons.length) return;\r\n    if (!this.plane) this.plane = polygons[0].plane.clone();\r\n    var front = [], back = [];\r\n    for (var i = 0; i < polygons.length; i++) {\r\n      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\r\n    }\r\n    if (front.length) {\r\n      if (!this.front) this.front = new CSG.Node();\r\n      this.front.build(front);\r\n    }\r\n    if (back.length) {\r\n      if (!this.back) this.back = new CSG.Node();\r\n      this.back.build(back);\r\n    }\r\n  }\r\n};","import {\r\n  Mesh, Matrix4, Vector3, Vector2, Material,\r\n  BufferGeometry, BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute\r\n} from 'three';\r\nimport { CSG } from './lib/csg/index.js';\r\n\r\nclass CSGWrapper {\r\n\r\n  #csg: CSG;\r\n\r\n  constructor(x: Mesh | CSG) {\r\n    this.#csg = (x instanceof CSG) ? x : meshToCsg(x);\r\n  }\r\n\r\n  subtract(x: Mesh | CSGWrapper) {\r\n    return new CSGWrapper(this.#csg.subtract(\r\n      x instanceof CSGWrapper ? x.#csg : meshToCsg(x)\r\n    ));\r\n  }\r\n\r\n  intersect(x: Mesh | CSGWrapper) {\r\n    return new CSGWrapper(this.#csg.intersect(\r\n      x instanceof CSGWrapper ? x.#csg : meshToCsg(x)\r\n    ));\r\n  }\r\n\r\n  union(x: Mesh | CSGWrapper) {\r\n    return new CSGWrapper(this.#csg.union(\r\n      x instanceof CSGWrapper ? x.#csg : meshToCsg(x)\r\n    ));\r\n  }\r\n\r\n  toMesh() {\r\n    return csgToMesh(this.#csg);\r\n  }\r\n}\r\n\r\nfunction $(mesh: Mesh) {\r\n  return new CSGWrapper(mesh);\r\n}\r\nexport { $ as CSG };\r\n\r\n\r\n\r\n//-\r\n// `THREE.Mesh` to CSG\r\n//\r\nfunction meshToCsg(mesh: Mesh) {\r\n  return CSG.fromPolygons(meshToPolygons(mesh));\r\n}\r\n\r\n\r\n// -\r\n// `THREE.Mesh` to `CSG.Polygon[]`\r\n//\r\nfunction meshToPolygons(mesh: Mesh) {\r\n\r\n  // Compute transformation matrix. The matrix is applied to geometry\r\n  // during \"populate position attribute\" step. This will save one loop.\r\n  const clone = mesh.clone();\r\n  clone.updateMatrix();\r\n  const { matrix } = clone;\r\n  const shouldApplyMatrix = !matrix.equals(new Matrix4());\r\n\r\n  // Array of `CSG.Polygon`.\r\n  const polygons = [];\r\n\r\n  const positions = mesh.geometry.attributes.position.array as Float32Array;\r\n  const { normal, uv, color } = mesh.geometry.attributes;\r\n  const normals = normal && normal.array as (undefined | Float32Array);\r\n  const uvs = uv && uv.array;\r\n  const colors = color && color.array as (undefined | Float32Array);\r\n  const indices = mesh.geometry.index && mesh.geometry.index.array;\r\n  const count = indices ? indices.length : positions.length / 3;\r\n\r\n  // Populate polygons; create `CSG.Polygon` for each 3-vertices.\r\n  // - `CSG.Polygon` contains `CSG.Vertex[]` and `THREE.Material`.\r\n  // - `CSG.Vertex` must contain `.pos` (CSG.Vector) and optionally include \r\n  //   `normal` (CSG.Vector), `uv` (THREE.Vector2) and `color` (CSG.Vector). \r\n\r\n  const groups = Array.isArray(mesh.material)\r\n    ? mesh.geometry.groups\r\n    : [{ start: 0, count, materialIndex: 0 }];\r\n\r\n  for (const { start, count, materialIndex } of groups) {\r\n    const material = Array.isArray(mesh.material)\r\n      ? mesh.material[materialIndex ?? 0]\r\n      : mesh.material;\r\n    for (let i = start; i < start + count; i += 3) {\r\n      const vertices = [];\r\n      for (let j = 0; j < 3; ++j) {\r\n        const n = indices ? indices[i + j] : i + j;\r\n        vertices.push(new CSG.Vertex(\r\n          shouldApplyMatrix\r\n            ? new Vector3().fromArray(positions, 3 * n).applyMatrix4(matrix)\r\n            : positions.subarray(3 * n, 3 * n + 3),\r\n          normals && normals.subarray(3 * n, 3 * n + 3),\r\n          uvs && new Vector2().fromArray(uvs, 2 * n),\r\n          colors && colors.subarray(3 * n, 3 * n + 3)\r\n        ));\r\n      }\r\n      polygons.push(new CSG.Polygon(vertices, material));\r\n    }\r\n  }\r\n\r\n  return polygons;\r\n}\r\n\r\n\r\n\r\n// -\r\n// `CSG{}` to `THREE.Mesh`. The mesh will contain an indexed\r\n// BufferGeometry which buffer attributes are sorted by `Material`.\r\n// \r\nfunction csgToMesh(csg: CSG) {\r\n\r\n  // Group vertices by `Material` and find vertex count in same loop. \r\n  const polygons = csg.toPolygons();\r\n  const matMap = new Map(); // Map<Material{}, CSG.Vertex[][]>\r\n  let vertexCount = 0;\r\n  for (const { vertices, shared: material } of polygons) {\r\n    if (matMap.has(material)) {\r\n      matMap.get(material).push(vertices);\r\n    }\r\n    else {\r\n      matMap.set(material, [vertices]);\r\n    }\r\n    vertexCount += vertices.length;\r\n  }\r\n\r\n  // Alloc TypedArrays to hold buffer attributes data.\r\n  const positions = new Float32Array(vertexCount * 3);\r\n  const normals = new Float32Array(vertexCount * 3);\r\n  const uvs = new Float32Array(vertexCount * 2);\r\n  const colors = new Float32Array(vertexCount * 3);\r\n\r\n  // Result mesh.\r\n  const geom = new BufferGeometry();\r\n  const materials: Material[] = [];\r\n  const mesh = new Mesh(geom, materials);\r\n\r\n  // Populate geometry (`geom.attributes`, `geom.index`, `geom.groups`) and \r\n  // meterials (`mesh.material`) in same loop.\r\n  let start = 0;\r\n  let count = 0; // indices count of the current render group.\r\n  let materialIndex = 0;\r\n\r\n  let positionsIdx = 0;\r\n  let normalsIdx = 0;\r\n  let uvsIdx = 0;\r\n  let colorsIdx = 0;\r\n\r\n  let someHasNormal; // truthy/falsy;\r\n  let someHasUv;     // ditto\r\n  let someHasColor;  // ditto\r\n\r\n  const indices = []; // holding actual data of element index buffer\r\n  let index = 0; // index number already used\r\n\r\n  for (const [material, vertsArray] of matMap.entries()) {\r\n    count = 0;\r\n    for (const verts of vertsArray) {\r\n\r\n      // Populate indices\r\n      for (let i = 1, I = verts.length - 1; i < I; ++i) {\r\n        indices.push(index, index + i, index + i + 1);\r\n      }\r\n      index += verts.length;\r\n      count += (verts.length - 2) * 3;\r\n\r\n      // Populate buffer attributes\r\n      for (const { pos, normal, uv, color } of verts) {\r\n        // `position`\r\n        positions[positionsIdx++] = pos.x;\r\n        positions[positionsIdx++] = pos.y;\r\n        positions[positionsIdx++] = pos.z;\r\n\r\n        // `normal`\r\n        someHasNormal || (someHasNormal = normal);\r\n        if (normal) {\r\n          normals[normalsIdx++] = normal.x;\r\n          normals[normalsIdx++] = normal.y;\r\n          normals[normalsIdx++] = normal.z;\r\n        }\r\n        else {\r\n          normalsIdx += 3;\r\n        }\r\n\r\n        // `uv`\r\n        someHasUv || (someHasUv = uv);\r\n        if (uv) {\r\n          uvs[uvsIdx++] = uv.x;\r\n          uvs[uvsIdx++] = uv.y;\r\n        }\r\n        else {\r\n          uvsIdx += 2;\r\n        }\r\n\r\n        // `color`\r\n        someHasColor || (someHasColor = color);\r\n        if (color) {\r\n          colors[colorsIdx++] = color.x;\r\n          colors[colorsIdx++] = color.y;\r\n          colors[colorsIdx++] = color.z;\r\n        }\r\n        else {\r\n          colorsIdx += 3;\r\n        }\r\n      }\r\n    }\r\n\r\n    materials.push(material);\r\n    geom.addGroup(start, count, materialIndex);\r\n    start += count;\r\n    materialIndex += 1;\r\n  }\r\n\r\n  // Set element index buffer.\r\n\r\n  if (index <= 65535) {\r\n    geom.index = new Uint16BufferAttribute(indices, 1);\r\n  }\r\n  else {\r\n    console.warn(\"index > 65535\");\r\n    geom.index = new Uint32BufferAttribute(indices, 1);\r\n  }\r\n\r\n  // Set buffer attributes.\r\n\r\n  geom.setAttribute(\"position\", new BufferAttribute(positions, 3));\r\n\r\n  if (someHasNormal) {\r\n    geom.setAttribute(\"normal\", new BufferAttribute(normals, 3));\r\n  }\r\n\r\n  if (someHasUv) {\r\n    geom.setAttribute(\"uv\", new BufferAttribute(uvs, 2));\r\n  }\r\n\r\n  if (someHasColor) {\r\n    geom.setAttribute(\"color\", new BufferAttribute(colors, 3));\r\n  }\r\n\r\n  return mesh;\r\n}"],"names":["__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","CSG","this","polygons","fromPolygons","csg","prototype","clone","map","p","toPolygons","union","a","Node","b","clipTo","invert","build","allPolygons","subtract","intersect","inverse","flip","Vector","x","y","z","arguments","length","negated","plus","minus","times","dividedBy","dot","lerp","t","Math","sqrt","unit","cross","Vertex","pos","normal","uv","color","interpolate","other","Plane","w","EPSILON","fromPoints","c","n","splitPolygon","polygon","coplanarFront","coplanarBack","front","back","polygonType","types","i","vertices","type","push","plane","j","ti","tj","vi","vj","v","Polygon","shared","reverse","node","temp","clipPolygons","slice","concat","bsp","CSGWrapper","constructor","_CSGWrapper_csg","set","__classPrivateFieldSet","meshToCsg","toMesh","matMap","Map","vertexCount","material","positions","Float32Array","normals","uvs","colors","geom","BufferGeometry","materials","mesh","Mesh","someHasNormal","someHasUv","someHasColor","start","count","materialIndex","positionsIdx","normalsIdx","uvsIdx","colorsIdx","indices","index","vertsArray","entries","verts","I","addGroup","Uint16BufferAttribute","console","warn","Uint32BufferAttribute","setAttribute","BufferAttribute","csgToMesh","$","updateMatrix","matrix","shouldApplyMatrix","equals","Matrix4","geometry","attributes","position","array","groups","Array","isArray","Vector3","fromArray","applyMatrix4","subarray","Vector2","meshToPolygons"],"mappings":"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"}