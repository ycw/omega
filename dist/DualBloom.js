import{WebGLRenderTarget as e,ShaderMaterial as s,UniformsUtils as t,Vector2 as r,Vector4 as i}from"three";import{Pass as a,FullScreenQuad as u}from"three/examples/jsm/postprocessing/Pass.js";import{CopyShader as n}from"three/examples/jsm/shaders/CopyShader.js";const f={uniforms:{tDiffuse:{value:null},uThreshold:{value:0}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform float uThreshold;\n    varying vec2 vUv;\n    void main() {\n      vec4 T = texture2D( tDiffuse, vUv );\n      float L = (T.r + T.r + T.g + T.g + T.g + T.b) / 6.;\n      gl_FragColor = step( uThreshold, L ) * T;\n    }\n  "},l={uniforms:{tDiffuse:{value:null},tBlurred:{value:null},uIntensity:{value:0}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tBlurred;\n    uniform float uIntensity;\n    varying vec2 vUv;\n    void main() {\n      vec4 D = texture2D( tDiffuse, vUv );\n      vec4 B = texture2D( tBlurred, vUv );\n      gl_FragColor = D + uIntensity * B;\n    }\n  "},h={uniforms:{tDiffuse:{value:null},uHalfPixel:{value:null}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 uHalfPixel;\n    varying vec2 vUv;\n    void main() {\n      gl_FragColor = (4. * texture2D( tDiffuse, vUv )\n        + texture2D( tDiffuse, vUv - uHalfPixel.xy )\n        + texture2D( tDiffuse, vUv + uHalfPixel.xy )\n        + texture2D( tDiffuse, vUv + vec2( uHalfPixel.x, -uHalfPixel.y ) )\n        + texture2D( tDiffuse, vUv + vec2( -uHalfPixel.x, uHalfPixel.y ) )\n      ) / 8.;\n    }\n  "},o={uniforms:{tDiffuse:{value:null},uOffset:{value:null}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec4 uOffset;\n    varying vec2 vUv;\n    void main() {\n      gl_FragColor = ( 2. * (\n        texture2D( tDiffuse, vUv + uOffset.xy )\n        + texture2D( tDiffuse, vUv - uOffset.xy )\n        + texture2D( tDiffuse, vUv + vec2( uOffset.x, -uOffset.y ) )\n        + texture2D( tDiffuse, vUv + vec2( -uOffset.x, uOffset.y ) )\n      ) + texture2D( tDiffuse, vUv + vec2( uOffset.z, 0. ) )\n        + texture2D( tDiffuse, vUv + vec2( 0., uOffset.w ) )\n        + texture2D( tDiffuse, vUv + vec2( -uOffset.z, 0. ) )\n        + texture2D( tDiffuse, vUv + vec2( 0., -uOffset.w ) )\n      ) / 12.;\n    }\n  "};class v extends a{fsQuad;constructor(){super(),this.fsQuad=new u(new s({uniforms:t.clone(h.uniforms),vertexShader:h.vertexShader,fragmentShader:h.fragmentShader})),this.fsQuad.material.uniforms.uHalfPixel.value=new r}render(e,s,t){this.fsQuad.material.uniforms.tDiffuse.value=t.texture,e.setRenderTarget(s),this.fsQuad.render(e)}}class m extends a{fsQuad;constructor(){super(),this.fsQuad=new u(new s({uniforms:t.clone(o.uniforms),vertexShader:o.vertexShader,fragmentShader:o.fragmentShader})),this.fsQuad.material.uniforms.uOffset.value=new i}render(e,s,t){this.fsQuad.material.uniforms.tDiffuse.value=t.texture,e.setRenderTarget(s),this.fsQuad.render(e)}}class d extends a{#e;#s;#t;#r;#i;#a;#u;#n;constructor({maxDuals:t=8,duals:r=4}={}){if(super(),t<1)throw new Error(`maxDuals (${t}) must >= 1`);this.#e=[],this.#s=[],this.#t=0|t,this.#r=r,this.#i=0,this.#f(),this.#a=null,this.#u=new e(0,0);for(let s=0,r=t;s<r;++s)this.#s[s]=new v,this.#s[t+s]=new m,this.#e[s]=new e(0,0),this.#e[t+s]=new e(0,0);this.#n=new u(new s(n))}setSize(e,s){for(let t=0,r=this.#t;t<r;++t)this.#e[t].setSize(Math.max(1,e>>t+1),Math.max(1,s>>t+1)),this.#e[2*r-t-1].setSize(Math.max(1,e>>t),Math.max(1,s>>t))}render(e,s,t){if(0===this.#i)return e.setRenderTarget(this.renderToScreen?null:s),this.#n.material.uniforms.tDiffuse.value=t.texture,void this.#n.render(e);this.#u=t;for(let s=0,t=this.#i;s<t;++s)this.#a=this.#e[s],this.#s[s].fsQuad.material.uniforms.uHalfPixel.value.set(.5/this.#u.width,.5/this.#u.height),this.#s[s].render(e,this.#a,this.#u),this.#u=this.#a;for(let t=this.#e.length,r=t-this.#i;r<t;++r)this.#a=r===t-1?this.renderToScreen?null:s:this.#e[r],this.#u&&(this.#s[r].fsQuad.material.uniforms.uOffset.value.set(.5/this.#u.width,.5/this.#u.height,1/this.#u.width,1/this.#u.height),this.#s[r].render(e,this.#a,this.#u),this.#u=this.#a)}#f(){this.#i=Math.min(Math.max(0,0|this.#r),this.maxDuals),this.duals!==this.#i&&console.warn(`effective duals is ${this.#i}`)}get duals(){return this.#r}set duals(e){this.#r=e,this.#f()}get maxDuals(){return this.#t}}class c extends a{#l;#h;#o;#v;#m;#d;#c;#x;constructor({threshold:r=.5,blurriness:i=.5,intensity:a=.5,maxDuals:n=8}={}){super(),this.#l=new u(new s({uniforms:t.clone(f.uniforms),vertexShader:f.vertexShader,fragmentShader:f.fragmentShader})),this.#c=this.#l.material.uniforms,this.#c.uThreshold.value=r,this.#h=new e(0,0),this.#o=new d({maxDuals:n}),this.#v=new e(0,0),this.blurriness=i,this.#m=new u(new s({uniforms:t.clone(l.uniforms),vertexShader:l.vertexShader,fragmentShader:l.fragmentShader})),this.#x=this.#m.material.uniforms,this.#x.uIntensity.value=a}render(e,s,t){0!==this.#x.uIntensity.value&&(e.setRenderTarget(this.#h),this.#c.tDiffuse.value=t.texture,this.#l.render(e),this.#o.renderToScreen=!1,this.#o.render(e,this.#v,this.#h)),this.renderToScreen?e.setRenderTarget(null):(e.setRenderTarget(s),this.clear&&e.clear()),this.#x.tDiffuse.value=t.texture,this.#x.tBlurred.value=this.#v.texture,this.#m.render(e)}setSize(e,s){this.#h.setSize(e,s),this.#v.setSize(e,s),this.#o.setSize(e,s)}get intensity(){return this.#x.uIntensity.value}set intensity(e){this.#x.uIntensity.value=e}get threshold(){return this.#c.uThreshold.value}set threshold(e){this.#c.uThreshold.value=e}get blurriness(){return this.#d}set blurriness(e){this.#d=e,e>1||e<0?(console.warn(`blurriness (${e}) will be clamped (in 0..1) internally`),this.#o.duals=Math.ceil(Math.max(0,Math.min(1,e))*this.#o.maxDuals)):this.#o.duals=Math.ceil(e*this.#o.maxDuals)}get maxDuals(){return this.#o.maxDuals}}export{c as DualBloomPass,d as DualBlurPass};
